package com.mhx.encryption.util.aes;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.thymeleaf.util.StringUtils;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Base64;

/**
 * 严格地说，AES和Rijndael加密法并不完全一样（虽然在实际应用中二者可以互换），因为Rijndael加密法可以支持更大范围的区块和密钥长度：AES的区块长度固定为128位，
 * 密钥长度则可以是128，192或256位；而Rijndael使用的密钥和区块长度可以是32位的整数倍，以128位为下限，256位为上限。加密过程中使用的密钥是由Rijndael密钥生成方案产生。
 * 大多数AES计算是在一个特别的有限域完成的。
 * AES加密过程是在一个4×4的字节矩阵上运作，这个矩阵又称为“体（state）”，其初值就是一个明文区块（矩阵中一个元素大小就是明文区块中的一个Byte）。
 * （Rijndael加密法因支持更大的区块，其矩阵行数可视情况增加）加密时，各轮AES加密循环（除最后一轮外）均包含4个步骤：
 *
 * AddRoundKey
 * —矩阵中的每一个字节都与该次回合金钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。
 * AddRoundKey步骤，回合密钥将会与原矩阵合并。在每次的加密循环中，都会由主密钥产生一把回合密钥（通过Rijndael密钥生成方案产生），
 * 这把密钥大小会跟原矩阵一样，以与原矩阵中每个对应的字节作异或（⊕）加法。
 *
 * SubBytes
 * —通过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。
 * 在SubBytes步骤中，矩阵中的各字节通过一个8位的S-box进行转换。这个步骤提供了加密法非线性的变换能力。 S-box与GF（2）上的乘法反元素有关，已知具有良好的非线性特性。
 * 为了避免简单代数性质的攻击，S-box结合了乘法反元素及一个可逆的仿射变换矩阵建构而成。此外在建构S-box时，刻意避开了固定点与反固定点，即以S-box替换字节的结果会相当于错排的结果。
 *
 * ShiftRows
 * —将矩阵中的每个横列进行循环式移位。
 * ShiftRows描述矩阵的行操作。在此步骤中，每一行都向左循环位移某个偏移量。在AES中（区块大小128位），第一行维持不变，第二行里的每个字节都向左循环移动一格。
 * 同理，第三行及第四行向左循环位移的偏移量就分别是2和3。128位和192比特的区块在此步骤的循环位移的模式相同。经过ShiftRows之后，矩阵中每一竖列，都是由输入矩阵中的每个不同列中的元素组成。
 * Rijndael算法的版本中，偏移量和AES有少许不同；对于长度256比特的区块，第一行仍然维持不变，第二行、第三行、第四行的偏移量分别是1字节、3字节、4位组。
 * 除此之外，ShiftRows操作步骤在Rijndael和AES中完全相同。
 *
 * MixColumns
 * —为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略MixColumns步骤，而以另一个AddRoundKey取代。
 *
 *
 *
 * Strictly speaking, ae s and rijndael encryption are not identical (although in practice they are interchangeable),
 * because rijndael encryption can support a wider range of blocks and key lengths: ae s has a fixed block length of 128 bits,
 * while the key length can be either 128,192 or 256 bits; rijndael uses keys and blocks that can be integer multiples of 32 bits,
 * with 128 bits as the lower limit and 256 bits as the upper limit. The key used in the encryption process is generated by the rijndael key generation scheme.
 * Most a, e, and s calculations are done in a particular finite field.
 * The encryption process operates on a 4×4 byte matrix, also known as "state", whose initial value is a plaintext block
 * (the size of an element in the matrix is a byte in the plaintext block). (rijndael encryption method supports larger blocks, and the number of matrix
 * rows increases depending on the situation.) When encrypting, each round of a, e and s encryption cycle (except the last round) consists of four steps:
 *
 * AddRoundKey
 * - Every byte in the matrix performs x o r operations with the round key; Each subkey is generated by a key generation scheme.
 * add round key step, the round key will be merged with the original matrix. In each encryption cycle, the master key will generate a round key
 * (generated by the rijndael key generation scheme). The key size will be the same as the original matrix, which is Xor addition with every
 * corresponding byte in the original matrix.
 *
 * SubBytes
 * Using a non-linear substitution function, each byte is replaced with the corresponding byte by a lookup table.
 * In the sub bytes step, each byte in the matrix is converted through an 8-bit s-box. This step provides the ability to transform the encryption nonlinearly.
 * The s-box is related to the multiplicative antielement on g f (2) and is known to have good nonlinear properties. In order to
 * avoid the attack of simple algebraic properties, s-box is constructed by combining multiplicative inverse elements and an invertible affine
 * transformation matrix. In addition, when constructing s-box, fixed point and anti-fixed point are avoided deliberately, that is,
 * the result of replacing bytes with s-box will be equivalent to the result of wrong arrangement.
 *
 * ShiftRows
 * - Each horizontal column in the matrix is cyclically shifted.
 * shift rows describes the row operations of the matrix. In this step, each row is cycled to the left by an offset. In a, e and s (block size 128 bits),
 * the first row remains the same, and each byte in the second row loops one space to the left. Similarly,
 * the offsets of the cyclic leftward displacement of the third and fourth rows are 2 and 3, respectively.
 * The 128-bit and 192-bit blocks have the same pattern of cyclic displacement in this step.
 * After shift rows, each column in the matrix is made up of elements from each of the different columns in the input matrix.
 * In the version of rijndael algorithm, the offset is slightly different from a, e and s; For a 256-bit block, the first row remains the same,
 * and the offsets of the second, third, and fourth rows are 1-byte, 3-byte, and 4-bit groups, respectively.
 * Other than that, the shift rows operation steps are exactly the same in rijndael and ae s.
 *
 * MixColumns
 * - In order to fully mix each straight line operation in the matrix. This step uses linear transformations to blend each of the four inline bytes.
 * The last encryption loop omits the mix columns step and replaces it with another add round key.
 */

/**
 * @className AesUtils
 * @description AES加密算法工具
 *              AES encryption algorithm tool
 * @author MuHongXin.
 * @date 2023/05/31 15:40
 * @version v1.0.0
 **/

public class AesUtils {
    private static final Logger logger = LoggerFactory.getLogger(AesUtils.class);
    /**
     * 可配置到Constant中，并读取配置文件注入,16位,自己定义
     *
     * ----------------------------------------------------------------------------------------丨
     * Can be configured into constant and read config file injection,16 bits, self defined.
     * ----------------------------------------------------------------------------------------丨
     */
    private static final String KEY = "9P3AAD7DA4Y154D5";

    /**
     * 参数分别代表 算法名称/加密模式/数据填充方式
     *
     * ----------------------------------------------------------------------------------------丨
     * The parameters represent the algorithm name, encryption mode, and data filling mode.
     * ----------------------------------------------------------------------------------------丨
     */
    private static final String ALGORITHM = "AES/ECB/PKCS5Padding";


    /**
     * @author: MuHongXin.
     * @dateTime: 下午3:00 2023/6/1
     * @description: 通过调用 KeyGenerator.getInstance("AES") 获取 KeyGenerator 实例，
     *                  并且指定使用AES算法生成密钥。
     *                  然后调用 kGen.generateKey() 方法生成一个 SecretKey 密钥对象。
     *                  接下来通过 secretKey.getEncoded() 获取密钥的字节数组，
     *                  并使用 Base64 对这个字节数组进行编码，
     *                  最后将编码后的结果转换为字符串类型。
     *                  得到的 encryptKey 就是生成的AES密钥。
     *
     * ------------------------------------------------------------------------------------------------丨
     *                  The generated AES key can be obtained by using                                 丨
     *                  KeyGenerator kGen = KeyGenerator.getInstance("AES");                           丨
     *                  kGen.init(128);,                                                               丨
     *                  followed by calling kGen.generateKey() to generate a SecretKey object,         丨
     *                  and finally calling secretKey.getEncoded() to get the raw key bytes.           丨
     *                  To use the key for encryption,                                                 丨
     *                  you need to create an instance of SecretKeySpec with the raw key bytes,        丨
     *                  and then use it to initialize the Cipher object.                               丨
     * ------------------------------------------------------------------------------------------------丨
     *
     * @param keyLength 密钥长度 128 / 192 / 256
     * @return java.lang.String
     **/
    public static String keyGenerator(int keyLength) {
        // 创建 KeyGenerator 实例 | Create a KeyGenerator instance
        KeyGenerator kGen = null;
        // 定义一个空字符串 | Define an empty string
        String key = "";
        try {
            // 获取 KeyGenerator 实例，指定算法为AES | Get the KeyGenerator instance, specify the algorithm as AES
            kGen = KeyGenerator.getInstance("AES");
        } catch (NoSuchAlgorithmException e) {
            // 如果抛出NoSuchAlgorithmException，则打印错误信息并返回空字符串 | If NoSuchAlgorithmException is thrown, print error message and return empty string
            logger.info("keyGenerator|149|abnormal:{}", Arrays.toString(e.getStackTrace()));
            return key;
        }

        // 初始化 KeyGenerator，指定密钥长度 | Initialize KeyGenerator and specify the key length
        kGen.init(keyLength);
        // 生成密钥 | Generate the key
        SecretKey secretKey = kGen.generateKey();
        // 将密钥编码为字节数组 | Encode the key as a byte array
        byte[] raw = secretKey.getEncoded();
        // 将字节数组进行 Base64 编码，并转换为字符串 | Base64 encode the byte array and convert it to a string
        key = new String(Base64.getEncoder().encode(raw));

        // 返回生成的密钥 | Return the generated key
        return key;
    }

    /**
     * @author: MuHongXin.
     * @dateTime: 下午4:25 2023/5/31
     * @description： AES 加密，使用任意字符串内容并指定加密所用密钥
     *
     * ----------------------------------------------------------------------------------------------------丨
     *                AES Encrypts, using any string content and specifying the key used for encryption.   丨
     *-----------------------------------------------------------------------------------------------------丨
     *
     * @param plaintext 明文
     * @param encryptKey 密钥
     * @return java.lang.String 密文 cipherText
     **/
    public static String encrypt(String plaintext, String encryptKey) throws Exception {
        if (StringUtils.isEmpty(plaintext) || StringUtils.isEmpty(encryptKey)) {
            throw new IllegalArgumentException("加密内容或秘钥为空! | The encryption content or key is empty!");
        }

        // 获取 Cipher 实例，指定加密算法为 AES | Get a Cipher instance and specify the encryption algorithm as AES
        Cipher cipher = Cipher.getInstance(ALGORITHM);

        // 初始化 Cipher，指定操作模式为 ENCRYPT_MODE | Initialize the Cipher, specify the operation mode as ENCRYPT_MODE
        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(encryptKey.getBytes(), "AES"));

        // 使用 Cipher 对明文进行加密，并将结果存储到字节数组中 | Encrypt the plaintext using Cipher and store the result in a byte array
        byte[] b = cipher.doFinal(plaintext.getBytes(StandardCharsets.UTF_8));

        // 将加密结果进行 Base64 编码，并转换为字符串 | Base64 encode the encrypted result and convert it to a string
        return org.apache.commons.codec.binary.Base64.encodeBase64String(b);
    }

    /**
     * @author: MuHongXin.
     * @dateTime: 下午4:25 2023/5/31
     * AES 解密，根据所用密钥对参数 'encryptStr' 进行解密
     *
     * ----------------------------------------------------------------------------------------------------丨
     * AES Decrypts, decrypts the parameter 'encryptStr' according to the used key.                        丨
     * ----------------------------------------------------------------------------------------------------丨
     *
     * @param cipherText 密文
     * @param decryptKey 密钥
     * @return java.lang.String 明文 plaintext
     **/
    public static String decrypt(String cipherText, String decryptKey) throws Exception {
        if (StringUtils.isEmpty(cipherText) || StringUtils.isEmpty(decryptKey)) {
            throw new IllegalArgumentException("加密内容或秘钥为空! | The encryption content or key is empty!");
        }

        // 获取 Cipher 实例，指定加密算法为 AES | Get a Cipher instance and specify the encryption algorithm as AES
        Cipher cipher = Cipher.getInstance(ALGORITHM);

        // 初始化 Cipher，指定操作模式为 DECRYPT_MODE，并指定解密密钥 | Initialize the Cipher, specify the operating mode as DECRYPT_MODE and specify the decryption key
        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(decryptKey.getBytes(), "AES"));

        // 对密文进行解码 | Decode the cipher text
        byte[] encryptBytes = org.apache.commons.codec.binary.Base64.decodeBase64(cipherText);

        // 解密密文，得到明文字节数组 | Decrypt the encrypted text to get the plain text byte array
        byte[] decryptBytes = cipher.doFinal(encryptBytes);

        // 将明文字节数组转换为字符串并返回 | Convert the plain text byte array to a string and return it
        return new String(decryptBytes);
    }

    /**
     * @author: MuHongXin.
     * @dateTime: 下午4:25 2023/5/31
     * @description: AES 加密，使用任意字符串内容及默认密钥进行加密
     *
     * ----------------------------------------------------------------------------丨
     * AES Encrypts, Encrypt with any string content and the default key.          丨
     * ----------------------------------------------------------------------------丨
     *
     * @param plaintext 明文
     * @return java.lang.String 密文 cipherText
     **/
    public static String encrypt(String plaintext) throws Exception {
        if (StringUtils.isEmpty(plaintext)) {
            throw new IllegalArgumentException("加密内容不能为空! | The encryption content cannot be empty!");
        }

        return encrypt(plaintext, KEY);
    }

    /**
     * @author: MuHongXin.
     * @dateTime: 下午4:25 2023/5/31
     * @description: AES 解密，使用默认密钥对密文进行解密
     *
     * ----------------------------------------------------------------------------丨
     * AES Decrypts, The default key is used to decrypt the cipher text.           丨
     * ----------------------------------------------------------------------------丨
     *
     * @param cipherText 密文
     * @return java.lang.String 明文 plaintext
     **/
    public static String decrypt(String cipherText) throws Exception {
        if (StringUtils.isEmpty(cipherText)) {
            throw new IllegalArgumentException("加密内容不能为空! | The encryption content cannot be empty!");
        }

        return decrypt(cipherText, KEY);
    }
}